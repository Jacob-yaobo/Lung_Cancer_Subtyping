experiment:
  name: "baseline_pet_2class"
  seed: 42
  output_dir: "baseline_pet_2class"   # 训练产物保存目录
  description: "只使用PET数据，进行ADC vs SCC的二分类任务，针对全部lung区域的3D实验"

paths:
  subjects_csv: "dataset/manifest.csv"      # 列包含: pid, center, pathology, fold_id
  splits_json:  "dataset/split.json"        # 5-fold的各个fold划分的train_pids, val_pids
  tasks_json:  "dataset/task.json"          # 定义 include_labels + label_map
  data_root:  "dataset/h5file"              # 存储数据的HDF5文件，包含了ct_data, pet_data, lesion_mask, lung_mask四个dataset; 以及pid, center, pathology, fold_id四个attribute

data:
  task_name: "ADC_vs_SCC"                     # 对应 tasks.json
  fold: "fold_0"                               # 对应 splits.json
 
  modalities: ["PET"]
  split_train: "train_pids"
  split_val: "val_pids"
  dtype: "float32"                            # "float32" | "float16"

dataloader:
  train:
    batch_size: 8
    shuffle: true
    num_workers: 0  # 避免多进程问题
    pin_memory: false  # 避免pin_memory相关的错误
    drop_last: true
  val:
    batch_size: 8
    shuffle: false
    num_workers: 0  # 避免多进程问题
    pin_memory: false  # 避免pin_memory相关的错误
    drop_last: false

transforms:
  # # 典型 3D 医学图像预处理/增强示例（按需在代码中实现）
  # common:
  #   # 读入后统一强度归一化策略（示例：z-score 到每模态的非零体素）
  #   intensity_norm: { method: "zscore", per_modality: true, nonzero_only: true }
  #   clip: { enabled: false, min: 0.0, max: 1.0 }  # PET 可按 SUVbw 上限裁剪；CT 可 HU 裁剪
  #   resize: { enabled: false, size: [128, 128, 128], mode: "trilinear" }  # 如需统一形状
  # train_aug:
  #   random_flip: { p: 0.5, dims: ["x","y","z"] }
  #   random_rotate: { p: 0.2, degrees: 10 }
  #   random_crop: { enabled: false, size: [96,96,96] }
  #   noise: { p: 0.1, sigma: 0.01 }
  # val_aug:
  #   # 验证集通常不开启随机增强
  #   pass: true

model:
  # 任选：resnet3d / unet3d / swin-unetr 等；这里给一个分类骨干示例
  # name: "resnet3d18"
  # in_channels: "auto"         # "auto" 表示由 len(data.modalities) 推导；也可手写整数
  # num_classes: "auto"         # "auto" 表示由 tasks.json 的 label_map 推导；也可手写整数
  # pretrained: false
  # dropout: 0.0

optimizer:
  # name: "AdamW"
  # lr: 1.0e-3
  # weight_decay: 0.01
  # betas: [0.9, 0.999]

scheduler:
  # name: "CosineAnnealingLR"   # 或 "OneCycleLR", "StepLR"
  # T_max: 100
  # eta_min: 1.0e-6
  # warmup:
  #   enabled: true
  #   epochs: 5
  #   factor: 0.1                 # 从 lr * factor 线性升到 lr

loss:
  # name: "CrossEntropyLoss"
  # label_smoothing: 0.0
  # class_weights: null          # 可设为 [w0, w1, ...] 或 "auto_by_inverse_freq"

train:
  # epochs: 100
  # amp: true                    # 混合精度
  # grad_accum_steps: 1
  # clip_grad_norm: 0.0          # >0 启用梯度裁剪
  # eval_interval: 1             # 每多少个 epoch 验证一次
  # save_top_k: 3                # 保存最优的 k 个权重（按 val 指标）
  # metric_primary: "val/auc"    # 作为“最优模型”的指标名

metrics:
  # 训练中计算与日志的指标
  # overall: ["acc", "auc", "f1_macro"]
  # per_class: ["precision", "recall"]
  # per_center: true             # 是否按 center 维度出报告

logging:
  # framework: "tensorboard"     # "tensorboard" | "wandb" | "none"
  # log_dir: "runs/baseline_pet_ct_cls"
  # wandb:
  #   project: "pet-ct-classification"
  #   entity: ""                 # 可留空
  #   run_name: "${experiment.name}"